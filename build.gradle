/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java Library project to get you started.
 * For more details take a look at the Java Libraries chapter in the Gradle
 * user guide available at https://docs.gradle.org/4.8.1/userguide/java_library_plugin.html
 */

plugins
{
   // Apply the java-library plugin to add support for Java Library
	id 'java-library'

	// Apply the eclipse plugin to add support for Eclipse
	id 'eclipse'

	// gradle-docker plugins
	id 'com.palantir.docker' version '0.21.0'
	id 'com.palantir.docker-run' version '0.21.0'

	// gradle-helm-plugin plugins
	id 'org.unbroken-dome.helm' version '0.3.0'
	id 'org.unbroken-dome.helm-releases' version '0.3.0'
	
	// gradle-jgitver-plugin pluin
//	id 'fr.brouillard.oss.gradle.jgitver' version '0.8.0'
	
	// gradle-git-version plugin
	id 'com.palantir.git-version' version '0.11.0'
	
	// Gradle Download Task
	id "de.undercouch.download" version '3.4.3'
	
	// ASSUMES GRADLE 2.12 OR HIGHER. Use plugin version 0.7.5 with earlier gradle versions
	id 'com.google.protobuf' version '0.8.8'
}

// Updating the version in our release process.
def grpcVersion = '1.21.0'
def protobufVersion = '3.7.1'
def protocVersion = protobufVersion

// Load environment variables
def envVarsProps = new Properties()
file("EnvFile.properties").withInputStream { envVarsProps.load(it) }

// Adding some properties
ext {
	serviceName = envVarsProps.SERVICE_NAME_ENV_VAR
	productRepository = "${serviceName}/${productName}"
//	productVersion = "v0.1.0-feature1"
//	productVersion = gitVersion()
	productVersion = manifestVersion()
	productK8ShelmChartsFolder = "k8s/helm/charts"
	externalEchoBeProtoFolderPath = buildDir.getName() + "/ext/main/proto"
	externalEchoBeProtoFilePath = "${externalEchoBeProtoFolderPath}/echo.proto"
}

dependencies
{
	// Use JUnit test framework
	testImplementation 'junit:junit:4.12'

	// Jersey
	implementation 'org.glassfish.jersey.containers:jersey-container-grizzly2-http:2.27'
	implementation 'org.glassfish.jersey.inject:jersey-hk2:2.27'

	// The production code uses the SLF4J logging API at compile time
	compile 'org.slf4j:slf4j-api:1.7.25'

	// gRPC
	implementation "io.grpc:grpc-protobuf:${grpcVersion}"
	implementation "io.grpc:grpc-stub:${grpcVersion}"
	compileOnly "javax.annotation:javax.annotation-api:1.2"
	runtimeOnly "io.grpc:grpc-netty-shaded:${grpcVersion}"
	
	// ProtoC
	protobuf files("${externalEchoBeProtoFolderPath}")
}

// In this section you declare where to find the dependencies of your project
repositories
{
	// Use jcenter for resolving your dependencies.
	// You can declare any Maven/Ivy/file repository here.
	jcenter()
}

// Configure protobuf
protobuf {
	protoc { 
   	artifact = "com.google.protobuf:protoc:${protocVersion}" 
   }
	plugins {
		grpc { 
			artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}" 
		}
	}
	generateProtoTasks {
		all()*.plugins { 
			grpc {} 
		}
	}
}

// Inform IDEs like IntelliJ IDEA, Eclipse or NetBeans about the generated code.
sourceSets {
	main {
		java {
			srcDirs buildDir.getName() + "/generated/source/proto/main/grpc"
			srcDirs buildDir.getName() + "/generated/source/proto/main/java"
		}
//		proto {
//			srcDirs "${externalEchoBeProtoFolderPath}"
//		}
	}
}

/* ----------------------------------------------------------------------------
 *
 *  Additional parts from EGradle template for comfortable eclipse setup
 *  (necessary, because every EGradle template MUST be importable out of the box)
 * 
 * ---------------------------------------------------------------------------- */

// To have javadocs in eclipse added - where no sources are available - we need these lines:
// see https://docs.gradle.org/current/dsl/org.gradle.plugins.ide.eclipse.model.EclipseClasspath.html
eclipse {	 
	classpath {
		downloadSources = true // default: true
		downloadJavadoc = true // default: false
	}
} 

// first define an array containing source folders to be always available - even when not existing already
def eclipseSourceFolders = [
	'src/main/java',
	'src/main/resources',
	'src/test/java',
	'src/test/resources'
];

// now create those source folders when not existing, when eclipse task is executed:
tasks.eclipse.dependsOn << {	
	for (String sourceFolder: eclipseSourceFolders) { 
		def resourceDir = new File(project.projectDir, sourceFolder)
		
		if (!resourceDir.exists() && !resourceDir.mkdirs()) {
    		logger.info("Not able to create %1",resourceDir);
    	}
	}
}

// Download shared resource with other repositories
task downloadEchoBeProtoFile(type: Download) {
//	def details = versionDetails()
	
//	src "https://raw.githubusercontent.com/tmeltser/echobe/${details.branchName}/src/main/proto/echo.proto"
	src "https://raw.githubusercontent.com/tmeltser/echobe/integration/src/main/proto/echo.proto"
	dest "${externalEchoBeProtoFilePath}"
//	overwrite true
	onlyIfModified true
}

// Define an Initializer task
task initializer(dependsOn: 'downloadEchoBeProtoFile')

// Make every other task depend on 'initializer'
// matching() and all() are "live" so any tasks declared after this line will also depend on 'initializer'
tasks.matching { it.name != 'initializer' && it.name != 'downloadEchoBeProtoFile' }.all { 
	Task task -> task.dependsOn initializer
}

// Create an uber jar
jar {
	manifest	{
   	attributes "Main-Class": "com.efrat.example.devops.echoServerFEApp.EchoServerFEApp"
	}

	from	{
		configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
	}
}

// Make prints in tests visible
test {
	systemProperties = System.properties

	outputs.upToDateWhen {false}

	testLogging {
		showStandardStreams = true
	}
}

//
// docker
//

docker {
	name "${productName}:${productVersion}"
	tag "privateRegistry", "${productRepository}:${productVersion}"	// For DockerHub registry
	buildArgs([JAR_PRODUCT_NAME:"${project.name}",JAR_PRODUCT_VERSION:"${productVersion}",PRODUCT_INTERNAL_PORT:"${productInternalPort}"])
	files jar.outputs
	copySpec.into(buildDir.getName() + "/libs")
//	pull true
//	noCache true
}

// Give an alias to docker task
task dockerBuild(dependsOn: ['jar','docker'])

dockerRun {
	name "${productName}"
	image "${productName}:${productVersion}"
	ports "${productExternalPort}:${productInternalPort}"
	env 'INTERNAL_PORT_ENV_VAR':"${productInternalPort}"
	env 'EXTERNAL_ECHOBE_HOST_ENV_VAR':echobeServiceEndPointHost
	env 'EXTERNAL_ECHOBE_PORT_ENV_VAR':echobeServiceEndPointPort
	env 'ENGAGE_MOCKUP_REMOTE_INTERFACES':engageMockupRemoteInterfaces
	daemonize true
	clean true
}

// Main task used from docker plugins
task dockerBuildAndPublish(dependsOn: 'dockerPushPrivateRegistry')

// Give an alias to dockerRun task
task dockerStart(dependsOn: ['dockerBuild','dockerRun'])

//
// helm
//

helm {
	home = file("$System.env.HOME/.helm")
	debug = true

	tiller {
		// Don't install the server
		install = false

		// Install/expect Tiller in a different namespace than kube-system
//		namespace = "custom-namespace"

		// Set a service account for Tiller
//		serviceAccount = "tiller-service-account"
	}

	filtering {
		// These values will be resolvable in all charts' YAML files (e.g. imageTag => ${productVersion})
		values.put 'imageTag',"${productVersion}"
		values.put 'imageRepository',"${productRepository}"
		values.put 'servicePort',"${productInternalPort}"
		values.put 'serviceTargetPort',"${productInternalPort}"
		values.put 'serviceNodePort',"${productExternalPort}"
		values.put 'externalEchobeHost',echobeServiceEndPointHost
		values.put 'externalEchobePort',echobeServiceEndPointPort
		values.put 'engageMockupRemoteInterfaces', engageMockupRemoteInterfaces
	}

	charts {
		echofe {
			chartVersion = "${productVersion}"
			sourceDir = file("${productK8ShelmChartsFolder}/${productName}")
		}
	}

	lint {
		// enable/disable linting by default
		enabled = true
		// treat linter warnings as errors (failing the build)
		strict = true
	}

	releases {
		echofe {
			from charts.echofe
			
			// Namespace to install the release into. Defaults to the current kube config namespace.
			namespace = manifestNamespace()
			
			// If true, the associated helmDelete task will purge the release, completely removing the release from the store and making its name free for later use
			purge = true

			// If true, the associated helmInstall task will replace an existing release with the same name (using helm install --replace instead of helm upgrade --install).			
//			replace = true 
						
			// If true, perform a dry run 
//			dryRun = true
			
			// pass values (like --set on the command line)
//			values = ['image.tag':"${productVersion}"]

			// If true, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment are in a ready state before marking the release as successful
//			wait = true
		}
	}
}

task helmUpdate(dependsOn: 'helmInstall')
task helmUninstall(dependsOn: 'helmDelete')

task helmTest(type:Exec) {
	executable "helm"
	args "test","${productName}"
}

task helmTestAndClean(type:Exec) {
	executable "helm"
	args "test","${productName}","--cleanup"
}

// Notes:
// 1. helmPackge and helmInstall tasks are used as is
// 2. helmInstall and helmUninstall (helmDelete) can be used with "-Phelm.dryRun"

//
// The function builds a proper version name indeed
//
def manifestVersion() {
	def details = versionDetails()

	// This doesn't work under Jenkins as it doesn't fetch the tags
//	return "${details.lastTag}.${details.branchName}"
	
	// An alternative (can also be "0.1.0-demo.${details.branchName}")
	return "0.1.0-${details.branchName}"

//	println "last tag is: ${details.lastTag}"
//	println "commitDistance is: ${details.commitDistance}"
//	println "gitHash is: ${details.gitHash}"
//	println "gitHashFull is: ${details.gitHashFull}" // full 40-character Git commit hash
//	println "branchName is: ${details.branchName}" // is null if the repository in detached HEAD mode
//	println "isCleanTag is: ${details.isCleanTag}"	
}

//
// Construct an applicable namespace to be used by the Helm Chart
//
def manifestNamespace() {
	def details = versionDetails()
	def namespace = details.branchName 

	// If we are on the production or staging branches return the regular name ($serviceName), else return the branch namne itself
	if (details.branchName == "${productionBranchName}" || details.branchName == "${stagingBranchName}") {
		namespace = serviceName
	}
	
	return namespace
}

description = 'The Echo Frontend demo product'
version = "${productVersion}"
