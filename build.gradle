/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java Library project to get you started.
 * For more details take a look at the Java Libraries chapter in the Gradle
 * user guide available at https://docs.gradle.org/4.8.1/userguide/java_library_plugin.html
 */

plugins
{
   // Apply the java-library plugin to add support for Java Library
	id 'java-library'

	// Apply the eclipse plugin to add support for Eclipse
	id 'eclipse'

	// taskTree plugin
	id 'com.dorongold.task-tree'

	// gradle-docker plugins
	id 'com.palantir.docker'
	id 'com.palantir.docker-run'

	// gradle-helm-plugin plugins
	id 'org.unbroken-dome.helm'
	id 'org.unbroken-dome.helm-releases'
	
	// Gradle Download Task
	id 'de.undercouch.download'
	
	// ASSUMES GRADLE 2.12 OR HIGHER. Use plugin version 0.7.5 with earlier gradle versions
	id 'com.google.protobuf'

	// Gradle Spawn Plugin
	id 'com.wiredforcode.spawn'

	// Reckon versioning plugin
	// Usage: ./gradlew [TASK] -Preckon.scope=minor|major -Preckon.stage=rc|final (default is minor and first stage in the list (ordered alphabetically)) -Dorg.ajoberstar.grgit.auth.username=<token>
	id 'org.ajoberstar.reckon'

	// Grgit plugin 
	id 'org.ajoberstar.grgit'
}

// Adding some specific properties
ext {
	externalEchoBeProtoFolderPath = buildDir.getName() + "/ext/main/proto"
	externalEchoBeProtoFilePath = "${externalEchoBeProtoFolderPath}/echo.proto"
}

dependencies
{
	// Use JUnit test framework
	testImplementation "junit:junit:${dep_junit_version}"
	
	// Jersey
	implementation "org.glassfish.jersey.containers:jersey-container-grizzly2-http:${dep_jersey_version}"
	implementation "org.glassfish.jersey.inject:jersey-hk2:${dep_jersey_version}"

	// The production code uses the SLF4J logging API at compile time
	compile "org.slf4j:slf4j-api:${dep_slf4j_version}"

	// gRPC
	implementation "io.grpc:grpc-protobuf:${dep_grpc_version}"
	implementation "io.grpc:grpc-stub:${dep_grpc_version}"
	compileOnly "javax.annotation:javax.annotation-api:${dep_javax_annotation_version}"
	runtimeOnly "io.grpc:grpc-netty-shaded:${dep_grpc_version}"
	
	// ProtoC
	protobuf files("${externalEchoBeProtoFolderPath}")
}

// Load environment variables
def envVarsProps = new Properties()
file("EnvFile.properties").withInputStream { envVarsProps.load(it) }

// Load common build logic
def	commonGradleFilePath = "./${-> envVarsProps.JENKINS_SLAVE_K8S_COMMON_SUB_MODULE_NAME}/common.gradle"
apply from: "${commonGradleFilePath}"

//
// Make specific adjustments
//

jar {
	manifest {
		attributes "Main-Class": productMainClass
	}
}

// Download shared resource with other repositories
task downloadEchoBeProtoFile(type: Download) {
	def branchName = obtainCurrentBranchName()
	
	src "https://raw.githubusercontent.com/tmeltser/echobe/${branchName}/src/main/proto/echo.proto"
	dest "${externalEchoBeProtoFilePath}"
//	overwrite true
	onlyIfModified true
}

// Define an Initializer task
task initializer(dependsOn: 'downloadEchoBeProtoFile')

// Make every other task depend on 'initializer'
// matching() and all() are "live" so any tasks declared after this line will also depend on 'initializer'
tasks.matching { it.name != 'initializer' && it.name != 'downloadEchoBeProtoFile' }.all { 
	Task task -> task.dependsOn initializer
}

// Adjust Docker
dockerRun {
	env 'EXTERNAL_ECHOBE_HOST_ENV_VAR':echobeServiceEndPointHost
	env 'EXTERNAL_ECHOBE_PORT_ENV_VAR':echobeServiceEndPointPort
	env 'ENGAGE_MOCKUP_REMOTE_INTERFACES':engageMockupRemoteInterfaces
}

// Adjust Helm
helm {
	filtering {
		// These values will be resolvable in all charts' YAML files (e.g. imageTag => ${productVersion})
		values.put 'serviceType',productServiceType
		values.put 'externalEchobeHost',echobeServiceEndPointHost
		values.put 'externalEchobePort',echobeServiceEndPointPort
		values.put 'engageMockupRemoteInterfaces',engageMockupRemoteInterfaces
	}
}

// Master task that runs a complete flow, except publishing the version
task DR (dependsOn: [dockerBuildAndPublish,helmPackage,helmUpdate,helmTestAndClean,certify]) {
	helmPackage.mustRunAfter dockerBuildAndPublish

	helmUpdate.mustRunAfter helmPackage

	helmTestAndClean.mustRunAfter helmUpdate

	certify.mustRunAfter helmTestAndClean
}

// Master task that runs a complete flow (like the Jenkins Pipeline)
task AIO (dependsOn: [DR,publishVersion]) {
	publishVersion.mustRunAfter DR
}
