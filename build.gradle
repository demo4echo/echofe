/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java Library project to get you started.
 * For more details take a look at the Java Libraries chapter in the Gradle
 * user guide available at https://docs.gradle.org/4.8.1/userguide/java_library_plugin.html
 */

plugins
{
	// Apply the java-library plugin to add support for Java Library
	id 'java-library'

	// Apply the eclipse plugin to add support for Eclipse
	id 'eclipse'

	// taskTree plugin
	id 'com.dorongold.task-tree'

	// gradle-docker plugins
	id 'com.palantir.docker'
	id 'com.palantir.docker-run'

	// gradle-helm-plugin plugins
	id 'org.unbroken-dome.helm'
	id 'org.unbroken-dome.helm-releases'
	id 'org.unbroken-dome.helm-publish'

	// Gradle Download Task
	id 'de.undercouch.download'

	// ASSUMES GRADLE 2.12 OR HIGHER. Use plugin version 0.7.5 with earlier gradle versions
	id 'com.google.protobuf'

	// Gradle Spawn Plugin
	id 'com.wiredforcode.spawn'

	// Reckon versioning plugin
	// Usage: ./gradlew [TASK] -Preckon.scope=minor|major -Preckon.stage=rc|final (default is minor and first stage in the list (ordered alphabetically)) -Dorg.ajoberstar.grgit.auth.username=<token>
	id 'org.ajoberstar.reckon'

	// Grgit plugin
	id 'org.ajoberstar.grgit'
}

// Pre-Defined project properties
project.description = 'The Echo Frontend demo product'

// Load common build logic
def	commonGradleFilePath = "./${-> common_sub_module_name}/common.gradle"
apply from: "${commonGradleFilePath}"

// Adding some specific properties
ext {
	branchName = obtainCurrentBranchName()
	externalEchoBeProtoFolderPath = buildDir.getName() + "/ext/main/proto"
	externalEchoBeProtoFilePath = "${externalEchoBeProtoFolderPath}/echo.proto"
	externalEchoBeProtoRemoteUrl = "https://raw.githubusercontent.com/${service_name}/echobe/${branchName}/src/main/proto/echo.proto"
}

dependencies
{
	// Use JUnit test framework
	testImplementation "junit:junit:${dep_junit_version}"

	// Jersey
	implementation "org.glassfish.jersey.containers:jersey-container-grizzly2-http:${dep_jersey_version}"
	implementation "org.glassfish.jersey.inject:jersey-hk2:${dep_jersey_version}"

	// The production code uses the SLF4J logging API at compile time
	compile "org.slf4j:slf4j-api:${dep_slf4j_version}"

	// gRPC
	implementation "io.grpc:grpc-protobuf:${dep_grpc_version}"
	implementation "io.grpc:grpc-stub:${dep_grpc_version}"
	compileOnly "javax.annotation:javax.annotation-api:${dep_javax_annotation_version}"
	runtimeOnly "io.grpc:grpc-netty-shaded:${dep_grpc_version}"

	// ProtoC
	protobuf files("${externalEchoBeProtoFolderPath}")
}

//
// Make specific adjustments
//

jar {
	manifest {
		attributes "Main-Class": productMainClass
	}
}

// Download shared resource with other repositories
task downloadEchoBeProtoFile(type: Download) {
	src externalEchoBeProtoRemoteUrl
	dest externalEchoBeProtoFilePath
//	overwrite true
	onlyIfModified true
}

// Make every task depend on 'downloadEchoBeProtoFile' (apart from the 'initializer' (and this task itself))
// matching() and all() are "live" so any tasks declared after this line will also depend on 'downloadEchoBeProtoFile'
tasks.matching { it.name != 'initializer' && it.name != 'downloadEchoBeProtoFile' }.all {
	Task task -> task.dependsOn downloadEchoBeProtoFile
}

// Adjust Docker
dockerRun {
	env 'EXTERNAL_ECHOBE_HOST_ENV_VAR':echobeServiceEndPointHost
	env 'EXTERNAL_ECHOBE_PORT_ENV_VAR':echobeServiceEndPointPort
	env 'ENGAGE_MOCKUP_REMOTE_INTERFACES':engageMockupRemoteInterfaces
}

// Adjust Helm
helm {
	filtering {
		// These values will be resolvable in all charts' YAML files (e.g. imageTag => ${productVersion})
		values.put 'serviceType',productServiceType
		values.put 'externalEchobeHost',echobeServiceEndPointHost
		values.put 'externalEchobePort',echobeServiceEndPointPort
		values.put 'engageMockupRemoteInterfaces',engageMockupRemoteInterfaces
	}
}

// Master task that runs a complete flow, except publishing the version and the artifacts
task DR (dependsOn: [manifestDockerImage,manifestHelmChart,helmUpdate,helmTestAndClean,certify]) {
	manifestHelmChart.mustRunAfter manifestDockerImage,dockerPublish

	helmUpdate.mustRunAfter manifestHelmChart

	helmTestAndClean.mustRunAfter helmUpdate
	
	certify.mustRunAfter helmTestAndClean
}

// Master task that runs a complete flow (like the Jenkins Pipeline)
task AIO (dependsOn: [DR,publishApplicableVersion]) {
	publishApplicableVersion.mustRunAfter DR
}
